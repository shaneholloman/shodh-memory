<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shodh Memory - Live Activity</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0a0a12;
            --surface: rgba(18, 22, 36, 0.95);
            --surface-2: rgba(25, 30, 48, 0.9);
            --border: rgba(80, 120, 200, 0.2);
            --text: #e8eaf6;
            --text-muted: #8892b0;
            --accent: #64ffda;
            --accent-2: #7c4dff;
            --create: #00e676;
            --access: #448aff;
            --search: #ffab40;
            --delete: #ff5252;
            --mono: 'JetBrains Mono', monospace;
        }

        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                radial-gradient(ellipse at 20% 80%, rgba(100, 255, 218, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(124, 77, 255, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(68, 138, 255, 0.05) 0%, transparent 60%);
            pointer-events: none;
            z-index: 0;
        }

        .app {
            position: relative;
            z-index: 1;
            display: grid;
            grid-template-columns: 320px 1fr 380px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            gap: 1px;
            background: var(--border);
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            background: var(--surface);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            border-bottom: 1px solid var(--border);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 18px;
            color: var(--bg);
        }

        .logo-text {
            font-size: 18px;
            font-weight: 600;
        }

        .logo-text span {
            color: var(--accent);
        }

        .status-bar {
            display: flex;
            align-items: center;
            gap: 24px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-dot.live { background: var(--create); }
        .status-dot.offline { background: var(--delete); animation: none; }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.9); }
        }

        .sse-indicator {
            font-family: var(--mono);
            font-size: 11px;
            color: var(--text-muted);
            padding: 4px 10px;
            background: rgba(100, 255, 218, 0.1);
            border-radius: 4px;
        }

        .sse-indicator.streaming {
            background: rgba(0, 230, 118, 0.15);
            color: var(--create);
            animation: pulse 2s infinite;
        }

        /* Sidebar - Controls */
        .sidebar {
            background: var(--surface);
            padding: 20px;
            overflow-y: auto;
        }

        .section {
            margin-bottom: 24px;
        }

        .section-title {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--accent);
            margin-bottom: 12px;
        }

        .input-group {
            margin-bottom: 12px;
        }

        .input-group label {
            display: block;
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        input, select {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px 12px;
            color: var(--text);
            font-family: inherit;
            font-size: 13px;
            transition: all 0.2s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(100, 255, 218, 0.1);
        }

        .btn {
            width: 100%;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            color: var(--bg);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 20px rgba(100, 255, 218, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 14px;
            text-align: center;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            line-height: 1;
        }

        .stat-label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-top: 4px;
        }

        /* Main Canvas Area */
        .main {
            background: var(--bg);
            position: relative;
            overflow: hidden;
        }

        #visualCanvas {
            width: 100%;
            height: 100%;
        }

        /* Activity Feed */
        .feed {
            background: var(--surface);
            padding: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .feed-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .feed-title {
            font-size: 14px;
            font-weight: 600;
        }

        .feed-badge {
            font-size: 11px;
            padding: 3px 8px;
            background: rgba(100, 255, 218, 0.15);
            color: var(--accent);
            border-radius: 10px;
        }

        .feed-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .activity-item {
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 10px;
            animation: slideIn 0.3s ease;
            transition: all 0.2s;
        }

        .activity-item:hover {
            border-color: var(--accent);
            transform: translateX(4px);
        }

        .activity-item.highlight {
            animation: highlight 1s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes highlight {
            0%, 100% { box-shadow: none; }
            50% { box-shadow: 0 0 20px rgba(100, 255, 218, 0.4); }
        }

        .activity-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .activity-type {
            font-size: 10px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 4px;
            text-transform: uppercase;
        }

        .activity-type.create { background: rgba(0, 230, 118, 0.2); color: var(--create); }
        .activity-type.access { background: rgba(68, 138, 255, 0.2); color: var(--access); }
        .activity-type.search { background: rgba(255, 171, 64, 0.2); color: var(--search); }
        .activity-type.delete { background: rgba(255, 82, 82, 0.2); color: var(--delete); }

        .activity-time {
            font-size: 10px;
            font-family: var(--mono);
            color: var(--text-muted);
            margin-left: auto;
        }

        .activity-content {
            font-size: 13px;
            line-height: 1.5;
            color: var(--text);
            word-break: break-word;
        }

        .activity-meta {
            display: flex;
            gap: 12px;
            margin-top: 8px;
            font-size: 11px;
            color: var(--text-muted);
        }

        .activity-meta span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Memory particles on canvas */
        .memory-particle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            pointer-events: none;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) scale(1); opacity: 0.8; }
            50% { transform: translateY(-20px) scale(1.2); opacity: 1; }
        }

        /* Neural connection animation */
        .neural-pulse {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--accent);
            border-radius: 50%;
            animation: neuralMove 2s linear forwards;
        }

        @keyframes neuralMove {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent); }

        /* SSE disconnected state */
        .sse-indicator.disconnected {
            background: rgba(255, 82, 82, 0.15);
            color: var(--delete);
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <div class="logo">
                <div class="logo-icon">S</div>
                <div class="logo-text">Shodh <span>Live</span></div>
            </div>
            <div class="status-bar">
                <div class="status-item">
                    <div class="status-dot live" id="statusDot"></div>
                    <span id="statusText">Connecting...</span>
                </div>
                <div class="sse-indicator" id="sseIndicator">SSE: Connecting...</div>
                <div class="status-item">
                    <span id="eventCount">0</span> events
                </div>
            </div>
        </header>

        <aside class="sidebar">
            <div class="section">
                <div class="section-title">User Filter</div>
                <div class="input-group">
                    <label>User ID</label>
                    <input type="text" id="userId" value="claude-code" placeholder="Enter user ID">
                </div>
                <button class="btn btn-primary" onclick="startMonitoring()">Start Monitoring</button>
            </div>

            <div class="section">
                <div class="section-title">Connection</div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="sseStatus" style="font-size: 14px;">-</div>
                        <div class="stat-label">SSE Stream</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="reconnects">0</div>
                        <div class="stat-label">Reconnects</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Live Statistics</div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalMemories">0</div>
                        <div class="stat-label">Memories</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="recentActivity">0</div>
                        <div class="stat-label">Activity/min</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgLatency">--</div>
                        <div class="stat-label">Latency</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="userCount">0</div>
                        <div class="stat-label">Users</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Brain State</div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="workingCount">0</div>
                        <div class="stat-label">Working</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="sessionCount">0</div>
                        <div class="stat-label">Session</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="longtermCount">0</div>
                        <div class="stat-label">Long-term</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgActivation">0%</div>
                        <div class="stat-label">Activation</div>
                    </div>
                </div>
                <button class="btn btn-secondary" onclick="fetchBrainState()">Refresh Brain</button>
            </div>

            <div class="section">
                <div class="section-title">Quick Test</div>
                <div class="input-group">
                    <label>Content</label>
                    <input type="text" id="testContent" placeholder="Test memory content...">
                </div>
                <button class="btn btn-secondary" onclick="createTestMemory()">Create Memory</button>
                <button class="btn btn-secondary" onclick="testSearch()">Test Search</button>
            </div>
        </aside>

        <main class="main">
            <canvas id="visualCanvas"></canvas>
        </main>

        <aside class="feed">
            <div class="feed-header">
                <span class="feed-title">Activity Stream</span>
                <span class="feed-badge" id="liveCount">LIVE</span>
            </div>
            <div class="feed-content" id="activityFeed">
                <div class="empty-state">
                    <div class="empty-state-icon">~</div>
                    <p>Waiting for activity...</p>
                    <p style="font-size: 12px; margin-top: 8px;">Click "Start Monitoring" to begin</p>
                </div>
            </div>
        </aside>
    </div>

    <script>
        const API = 'http://127.0.0.1:3030';
        // API key must be set via environment variable SHODH_API_KEY
        // For browser testing, update this value or load from server config
        const KEY = localStorage.getItem('apiKey') || '';

        // State
        let eventSource = null;
        let activityPerMinute = [];
        let isMonitoring = false;
        let canvas, ctx;
        let particles = [];
        let eventCounter = 0;
        let reconnectCount = 0;
        let totalMemories = 0;
        let brainState = null; // Stores current brain state for visualization
        let brainNeurons = []; // Persistent neurons for brain visualization

        // Canvas setup
        function initCanvas() {
            canvas = document.getElementById('visualCanvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            animate();
        }

        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
        }

        // Particle class for memory visualization
        class Particle {
            constructor(type, content) {
                this.x = Math.random() * canvas.width;
                this.y = canvas.height + 20;
                this.targetY = 100 + Math.random() * (canvas.height - 200);
                this.targetX = 100 + Math.random() * (canvas.width - 200);
                this.size = 4 + Math.random() * 8;
                this.speed = 2 + Math.random() * 3;
                this.type = type;
                this.content = content;
                this.alpha = 1;
                this.life = 1;
                this.decay = 0.002 + Math.random() * 0.003;
                this.pulsePhase = Math.random() * Math.PI * 2;

                switch(type) {
                    case 'create': this.color = '#00e676'; break;
                    case 'access': this.color = '#448aff'; break;
                    case 'search': this.color = '#ffab40'; break;
                    default: this.color = '#64ffda';
                }
            }

            update() {
                // Move towards target
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 5) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                } else {
                    // Gentle floating
                    this.x += Math.sin(Date.now() * 0.001 + this.pulsePhase) * 0.3;
                    this.y += Math.cos(Date.now() * 0.001 + this.pulsePhase) * 0.3;
                }

                this.life -= this.decay;
                this.alpha = Math.max(0, this.life);

                return this.life > 0;
            }

            draw() {
                // Glow effect
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.size * 2
                );
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(0.4, this.color + '80');
                gradient.addColorStop(1, 'transparent');

                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
                ctx.fill();

                // Core
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * (0.8 + 0.2 * Math.sin(Date.now() * 0.005 + this.pulsePhase)), 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1;
            }
        }

        // Brain Neuron class for persistent memory visualization
        class BrainNeuron {
            constructor(memory, tier, index, total) {
                this.id = memory.id;
                this.content = memory.content_preview;
                this.activation = memory.activation;
                this.importance = memory.importance;
                this.tier = tier;

                // Position based on tier (working=top, session=middle, longterm=bottom)
                const tierY = tier === 'working' ? 0.2 : tier === 'session' ? 0.5 : 0.8;
                const spread = Math.min(total, 20);
                const xOffset = (index % spread) / spread;

                this.x = 50 + xOffset * (canvas.width - 100);
                this.y = tierY * canvas.height + (Math.random() - 0.5) * 60;
                this.targetX = this.x;
                this.targetY = this.y;
                this.size = 4 + this.importance * 8;
                this.pulsePhase = Math.random() * Math.PI * 2;

                // Color based on tier
                this.color = tier === 'working' ? '#00e676' :
                            tier === 'session' ? '#ffab40' : '#448aff';
            }

            update() {
                // Gentle floating based on activation
                const floatAmount = this.activation * 3;
                this.x = this.targetX + Math.sin(Date.now() * 0.001 + this.pulsePhase) * floatAmount;
                this.y = this.targetY + Math.cos(Date.now() * 0.0008 + this.pulsePhase) * floatAmount;
            }

            draw() {
                // Glow based on activation
                const glowSize = this.size * (1 + this.activation);
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, glowSize * 2
                );
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(0.3, this.color + Math.floor(this.activation * 128).toString(16).padStart(2, '0'));
                gradient.addColorStop(1, 'transparent');

                ctx.globalAlpha = 0.3 + this.activation * 0.7;
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize * 2, 0, Math.PI * 2);
                ctx.fill();

                // Core with pulse
                const pulseScale = 0.9 + 0.1 * Math.sin(Date.now() * 0.003 + this.pulsePhase);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * pulseScale, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1;
            }
        }

        // Connection animation between particles
        function drawConnections() {
            ctx.strokeStyle = 'rgba(100, 255, 218, 0.1)';
            ctx.lineWidth = 1;

            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 150) {
                        const alpha = (1 - dist / 150) * 0.3 * particles[i].alpha * particles[j].alpha;
                        ctx.strokeStyle = `rgba(100, 255, 218, ${alpha})`;
                        ctx.beginPath();
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.stroke();
                    }
                }
            }
        }

        // Animation loop
        function animate() {
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(100, 255, 218, 0.03)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Update and draw connections
            drawConnections();

            // Draw tier labels if brain neurons exist
            if (brainNeurons.length > 0) {
                ctx.fillStyle = 'rgba(100, 255, 218, 0.5)';
                ctx.font = '11px Inter, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('WORKING MEMORY', 10, canvas.height * 0.2 - 30);
                ctx.fillStyle = 'rgba(255, 171, 64, 0.5)';
                ctx.fillText('SESSION MEMORY', 10, canvas.height * 0.5 - 30);
                ctx.fillStyle = 'rgba(68, 138, 255, 0.5)';
                ctx.fillText('LONG-TERM MEMORY', 10, canvas.height * 0.8 - 30);
            }

            // Update and draw brain neurons (persistent)
            for (const neuron of brainNeurons) {
                neuron.update();
                neuron.draw();
            }

            // Draw connections between brain neurons
            ctx.lineWidth = 0.5;
            for (let i = 0; i < brainNeurons.length; i++) {
                for (let j = i + 1; j < brainNeurons.length; j++) {
                    const dx = brainNeurons[i].x - brainNeurons[j].x;
                    const dy = brainNeurons[i].y - brainNeurons[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 100) {
                        const alpha = (1 - dist / 100) * 0.15 * brainNeurons[i].activation * brainNeurons[j].activation;
                        ctx.strokeStyle = `rgba(100, 255, 218, ${alpha})`;
                        ctx.beginPath();
                        ctx.moveTo(brainNeurons[i].x, brainNeurons[i].y);
                        ctx.lineTo(brainNeurons[j].x, brainNeurons[j].y);
                        ctx.stroke();
                    }
                }
            }

            // Update and draw particles (transient events)
            particles = particles.filter(p => {
                const alive = p.update();
                if (alive) p.draw();
                return alive;
            });

            // Center info
            if (!isMonitoring) {
                ctx.fillStyle = 'rgba(100, 255, 218, 0.3)';
                ctx.font = '14px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Click "Start Monitoring" to visualize memory activity', canvas.width / 2, canvas.height / 2);
            } else if (particles.length === 0) {
                ctx.fillStyle = 'rgba(100, 255, 218, 0.2)';
                ctx.font = '12px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Waiting for memory events...', canvas.width / 2, canvas.height / 2);
            }

            requestAnimationFrame(animate);
        }

        // Add activity to feed
        function addActivity(type, content, details = {}) {
            const feed = document.getElementById('activityFeed');
            const emptyState = feed.querySelector('.empty-state');
            if (emptyState) emptyState.remove();

            const item = document.createElement('div');
            item.className = 'activity-item highlight';

            const time = new Date().toLocaleTimeString('en-US', {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                fractionalSecondDigits: 3
            });

            item.innerHTML = `
                <div class="activity-header">
                    <span class="activity-type ${type}">${type.toUpperCase()}</span>
                    <span class="activity-time">${time}</span>
                </div>
                <div class="activity-content">${content.slice(0, 150)}${content.length > 150 ? '...' : ''}</div>
                ${details.score ? `<div class="activity-meta"><span>Score: ${(details.score * 100).toFixed(1)}%</span></div>` : ''}
                ${details.id ? `<div class="activity-meta"><span>ID: ${details.id.slice(0, 12)}...</span></div>` : ''}
            `;

            feed.insertBefore(item, feed.firstChild);

            // Keep only last 50 items
            while (feed.children.length > 50) {
                feed.removeChild(feed.lastChild);
            }

            // Remove highlight after animation
            setTimeout(() => item.classList.remove('highlight'), 1000);

            // Create particle
            particles.push(new Particle(type, content));

            // Update event counter
            eventCounter++;
            document.getElementById('eventCount').textContent = eventCounter;

            // Track activity per minute
            activityPerMinute.push(Date.now());
            activityPerMinute = activityPerMinute.filter(t => Date.now() - t < 60000);
            document.getElementById('recentActivity').textContent = activityPerMinute.length;
        }

        // Connect to SSE event stream
        function connectSSE() {
            if (eventSource) {
                eventSource.close();
            }

            const sseIndicator = document.getElementById('sseIndicator');
            const sseStatus = document.getElementById('sseStatus');

            sseIndicator.textContent = 'SSE: Connecting...';
            sseIndicator.classList.remove('streaming');
            sseStatus.textContent = '...';

            eventSource = new EventSource(`${API}/api/events`);

            eventSource.onopen = () => {
                sseIndicator.textContent = 'SSE: Streaming';
                sseIndicator.classList.add('streaming');
                sseStatus.textContent = 'LIVE';
                sseStatus.style.color = 'var(--create)';
                document.getElementById('statusDot').className = 'status-dot live';
                document.getElementById('statusText').textContent = 'Connected';
            };

            // Listen for CREATE events (new memories)
            eventSource.addEventListener('CREATE', (e) => {
                const event = JSON.parse(e.data);
                const content = event.content_preview || 'New memory';
                const type = event.experience_type || 'Unknown';
                totalMemories++;
                document.getElementById('totalMemories').textContent = totalMemories;
                addActivity('create', `[${type}] ${content}`, {
                    id: event.memory_id,
                    importance: event.importance
                });
            });

            // Listen for RETRIEVE events (searches)
            eventSource.addEventListener('RETRIEVE', (e) => {
                const event = JSON.parse(e.data);
                const query = event.content_preview || 'query';
                const count = event.count || 0;
                addActivity('search', `Search: "${query}" - Found ${count} results`);
            });

            // Listen for DELETE events
            eventSource.addEventListener('DELETE', (e) => {
                const event = JSON.parse(e.data);
                if (totalMemories > 0) totalMemories--;
                document.getElementById('totalMemories').textContent = totalMemories;
                addActivity('delete', `Memory ${event.memory_id?.slice(0, 12) || 'unknown'}... deleted`);
            });

            // Listen for GRAPH_UPDATE events
            eventSource.addEventListener('GRAPH_UPDATE', (e) => {
                const event = JSON.parse(e.data);
                addActivity('access', `Graph updated: ${event.content_preview || 'entity change'}`);
            });

            eventSource.onerror = (e) => {
                sseIndicator.textContent = 'SSE: Reconnecting...';
                sseIndicator.classList.remove('streaming');
                sseStatus.textContent = 'RETRY';
                sseStatus.style.color = 'var(--search)';
                document.getElementById('statusDot').className = 'status-dot offline';
                document.getElementById('statusText').textContent = 'Reconnecting...';

                // EventSource auto-reconnects, track reconnect count
                reconnectCount++;
                document.getElementById('reconnects').textContent = reconnectCount;
            };
        }

        // Disconnect SSE
        function disconnectSSE() {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
            document.getElementById('sseIndicator').textContent = 'SSE: Disconnected';
            document.getElementById('sseIndicator').classList.remove('streaming');
            document.getElementById('sseStatus').textContent = 'OFF';
            document.getElementById('sseStatus').style.color = 'var(--text-muted)';
        }

        // Fetch brain state visualization
        async function fetchBrainState() {
            const userId = document.getElementById('userId').value.trim();
            if (!userId) {
                addActivity('access', 'Please enter a User ID first');
                return;
            }

            try {
                const res = await fetch(`${API}/api/brain/${encodeURIComponent(userId)}`, {
                    headers: { 'X-API-Key': KEY }
                });

                if (!res.ok) {
                    addActivity('access', `Brain state fetch failed: ${res.status}`);
                    return;
                }

                const data = await res.json();
                brainState = data;

                // Update stats display
                document.getElementById('workingCount').textContent = data.stats.working_count;
                document.getElementById('sessionCount').textContent = data.stats.session_count;
                document.getElementById('longtermCount').textContent = data.stats.longterm_count;
                document.getElementById('avgActivation').textContent =
                    (data.stats.avg_activation * 100).toFixed(0) + '%';

                // Build brain neurons for visualization
                brainNeurons = [];

                data.working_memory.forEach((mem, i) => {
                    brainNeurons.push(new BrainNeuron(mem, 'working', i, data.working_memory.length));
                });

                data.session_memory.forEach((mem, i) => {
                    brainNeurons.push(new BrainNeuron(mem, 'session', i, data.session_memory.length));
                });

                data.longterm_memory.forEach((mem, i) => {
                    brainNeurons.push(new BrainNeuron(mem, 'longterm', i, data.longterm_memory.length));
                });

                addActivity('access', `Brain state loaded: ${data.stats.total_memories} memories across 3 tiers`);

            } catch (e) {
                console.error('Brain state fetch error:', e);
                addActivity('access', `Brain state error: ${e.message}`);
            }
        }

        // Check health
        async function checkHealth() {
            try {
                const res = await fetch(`${API}/health`);
                const data = await res.json();

                document.getElementById('statusDot').className = 'status-dot ' + (res.ok ? 'live' : 'offline');
                document.getElementById('statusText').textContent = res.ok ? 'Connected' : 'Error';
                document.getElementById('userCount').textContent = data.users_count || 0;
            } catch (e) {
                document.getElementById('statusDot').className = 'status-dot offline';
                document.getElementById('statusText').textContent = 'Offline';
            }
        }

        // Start monitoring via SSE
        function startMonitoring() {
            isMonitoring = true;

            // Get initial memory count (one-time fetch)
            fetchInitialStats();

            // Fetch brain state visualization
            fetchBrainState();

            // Connect to SSE stream
            connectSSE();

            addActivity('access', 'Started SSE monitoring - real-time event streaming active');
        }

        // Fetch initial stats (one-time, lightweight)
        async function fetchInitialStats() {
            const userId = document.getElementById('userId').value.trim();
            try {
                const res = await fetch(`${API}/api/memories`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-API-Key': KEY },
                    body: JSON.stringify({ user_id: userId, limit: 1 })
                });
                if (res.ok) {
                    const data = await res.json();
                    totalMemories = data.total_count || (data.memories?.length || 0);
                    document.getElementById('totalMemories').textContent = totalMemories;
                }
            } catch (e) {
                console.error('Initial stats fetch error:', e);
            }
        }

        // Create test memory
        async function createTestMemory() {
            const userId = document.getElementById('userId').value.trim();
            const content = document.getElementById('testContent').value.trim() ||
                `Test memory created at ${new Date().toISOString()}`;

            try {
                const res = await fetch(`${API}/api/record`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-API-Key': KEY },
                    body: JSON.stringify({
                        user_id: userId,
                        experience: { content, experience_type: 'Observation' }
                    })
                });

                if (res.ok) {
                    document.getElementById('testContent').value = '';
                }
            } catch (e) {
                console.error('Create error:', e);
            }
        }

        // Test search
        async function testSearch() {
            const userId = document.getElementById('userId').value.trim();
            const query = document.getElementById('testContent').value.trim() || 'test';

            try {
                const res = await fetch(`${API}/api/retrieve`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-API-Key': KEY },
                    body: JSON.stringify({ user_id: userId, query, limit: 5 })
                });

                if (res.ok) {
                    const data = await res.json();
                    const memories = data.memories || [];

                    addActivity('search', `Search: "${query}" - Found ${memories.length} results`);

                    for (const mem of memories.slice(0, 3)) {
                        const content = mem.experience?.content || mem.content || '';
                        addActivity('access', content, { score: mem.score, id: mem.id });
                    }
                }
            } catch (e) {
                console.error('Search error:', e);
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target.id === 'testContent') {
                createTestMemory();
            }
            if (e.key === 's' && e.ctrlKey) {
                e.preventDefault();
                testSearch();
            }
        });

        // Initialize
        initCanvas();
        checkHealth();
        setInterval(checkHealth, 5000);
    </script>
</body>
</html>
